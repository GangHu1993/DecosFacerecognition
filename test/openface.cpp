#include "openface/torchinterface.hpp"
#include "openface/neuralnetwork.hpp"
#include "openface/face.hpp"
#include "openface/facealigner.hpp"
#include "detection/facedetector.hpp"
#include <gtest/gtest.h>

//! @cond HIDDEN_SYMBOLS
class FaceTest : public ::testing::Test {
protected:
    void SetUp() {
        Image img("test/resources/image.jpg");
        FaceDetector fd;
        aligner.load("resources/shape_predictor_68_face_landmarks.dat");

        r = fd.detect(img);
        f = r.face;
    }

    Detection r;
    Face f;
    FaceAligner aligner;
};
//! @endcond

/**
 * @fn Face::align()
 *
 * @test
 * Correct size if aligned.
 */
TEST_F(FaceTest, TestFaceAlignment) {
    aligner.align(r);

    EXPECT_EQ(r.face.width(), FACE_SIZE_CONSTRAINT);
    EXPECT_EQ(r.face.height(), FACE_SIZE_CONSTRAINT);
}

//TODO(Jan): Add a test for alignment impossible

/**
 * @fn NeuralNetwork::forward_nn()
 *
 * @test
 * Correct output from neural network by comparing to ouput that was
 * generated by the python implementation of OpenFace itself.
 */
TEST (NeuralNetworkTest, NeuralNetworkForward) {
    NeuralNetwork nn("src/openface/forward_nn.lua", "resources/nn4.v2.t7");
    Image img("test/resources/face.png");
    Face face(img, true);
    FaceNetEmbed rep = nn.forward_nn(face);

    // Check the first five elements of the vector
    EXPECT_NEAR(rep(0), -0.07, 0.01);
    EXPECT_NEAR(rep(1), -0.01, 0.01);
    EXPECT_NEAR(rep(2), -0.03, 0.01);
    EXPECT_NEAR(rep(3), 0.08, 0.01);
    EXPECT_NEAR(rep(4), -0.06, 0.01);
}

// TODO(Jan): Add test for unaligned face.

/**
 * @test
 * Calling a generic lua function without arguments.
 */
TEST (TorchInterfaceTest, CallingFunctionNoArguments) {
    TorchInterface torch;
    torch.doFile("test/test.lua");
    std::string result = torch["hello_world"]();
    EXPECT_EQ(result, "Hello World");
};

/**
 * @test
 * Calling a function that does not exist and catch a lua::RuntimeError
 */
TEST (TorchInterfaceTest, CallingUndefinedFunction) {
    TorchInterface torch;
    torch.doFile("test/test.lua");
    try {
        std::string result = torch["hello"].call();
    }
    catch (lua::RuntimeError err) {
        EXPECT_STREQ(err.what(),"attempt to call a nil value");
    }
    catch (...) {
        FAIL() << "Expected different kind of exception";
    }
};

// TODO(Jan): Add tests for Torch class
// TODO(Jan): Add tests for OpenFace class

/**
 * @test
 * Calling a torch script function with a Tensor as argument.
 */
TEST (TorchInterfaceTest, TestTensorToTorch) {
    TorchInterface torch;
    torch.doFile("test/test.lua");
    float raw_data[] = {1.0, 2.0, 3.0};
    Tensor data(TensorNew1d(3));
    float* tensor_data = TensorData(data.raw());
    tensor_data[0] = raw_data[0];
    tensor_data[1] = raw_data[1];
    tensor_data[2] = raw_data[2];
    testing::internal::CaptureStdout();
    torch["tensor_input"](data);
    std::string output = testing::internal::GetCapturedStdout();
    EXPECT_EQ(std::string(" 2\n 4\n 6\n[torch.FloatTensor of size 3]\n\n"), output);
};

/**
 * @test
 * Calling a torch script function with wrong argument type and catch lua::RuntimeError
 */
TEST (TorchInterfaceTest, TestWrongInputType) {
    TorchInterface torch;
    torch.doFile("test/test.lua");
    try {
        torch["tensor_input"].call("Hello World");
        FAIL();
    }
    catch (lua::RuntimeError err) {}
    catch (...) {FAIL() << "Expected lua::RuntimeError";}
};

/**
 * @test
 * Calling a torch script function that returns a tensor and see if the result
 * is accessable form within the C++ program.
 */
TEST (TorchInterfaceTest, TestTensorFromTorch) {
    TorchInterface torch;
    torch.doFile("test/test.lua");
    Tensor data = torch["tensor_output"]();
    float* tensor_data = TensorData(data.raw());
    EXPECT_EQ(data.raw()->size[0], 3);
    EXPECT_EQ(tensor_data[0], 1);
    EXPECT_EQ(tensor_data[1], 2);
    EXPECT_EQ(tensor_data[2], 3);
};

/**
 * @test
 * Loading a non existent file and catch lua::LoadError.
 */
TEST (TorchInterfaceTest, LoadingNonExistingFile) {
    TorchInterface torch;
    try {
        torch.doFile("test/hello.lua");
    }
    catch (lua::LoadError err) {
        EXPECT_STREQ(err.what(),"cannot open test/hello.lua: No such file or directory");
    }
    catch (...) {
        FAIL() << "Expected different kind of exception";
    }
};
